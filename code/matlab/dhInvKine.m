% dhInvKine:  Returns the parameter list necessary to achieve a desired
% homogeneous transformation matrix and the residual error in that
% transfrom.
% 
%   [paramList, error] = dhInvKine(linkList, desTransform, paramListGuess)
%   This function performs the inverse kinematics of a robot described by
%   the DH parameters in linkList (a list of robot links generated by
%   createLink()) using numerical methods.  If no initial guess is provided
%   it will be assigned 0.  The function will then iterate using the
%   Newtom-Raphson method to find the desTransform matrix within a set
%   tolerance error by changing the joint parameters.  The resulting joint
%   parameters and the error value are returned.
%
%   paramList = list of joint parameters obtained from iteration (nx1)
%   error = error tolerance reached to satisfy convergence
%
%   linkList = list of links created by createLink() (nx1)
%   desTransform = the desired transformation matrix to be achieved (4x4)
%   paramListGuess = initial guess value for the joint parameters
%   (nx1)(optional)
%
%   Kyle Larsen
%   10832395
%   MEGN544
%   19 Nov 2017

function [paramList, error] = dhInvKine(linkList, desTransform, paramListGuess)

    if (~exist('paramListGuess', 'var'))
        paramListGuess = zeros(length(linkList),1);
    end
    
    paramList = paramListGuess;
    error_tol = 1*10^-10;
    tolNotReached = true;
    
    % Start timer
    tic;
    while (tolNotReached)
        %----- Solve for Position and Orientation Error
        curTransform = dhFwdKine(linkList, paramList);
        % Position
        P_current = curTransform(1:3,4);
        P_target = desTransform(1:3,4);
        P_error = P_target - P_current;

        % Orientation
        R_current = curTransform(1:3,1:3);
        R_target = desTransform(1:3,1:3);
        R_error = R_current'*R_target;
        [k_error, theta_error] = rot2AngleAxis(R_error);
        O_error = (R_current*k_error)*theta_error;

        %----- Find paramList_Step
        % Check for singularities
        Jv = velocityJacobian(linkList, paramList);
        [U,S,V] = svd(Jv);
        sigma = diag(S);
        sigma_inv = zeros(size(sigma));
        sigma_tol = 1*10^-10;
        for i = 1:length(sigma)
            if (sigma(i) < sigma_tol)
                sigma_inv(i) = 0;
            else
                sigma_inv(i) = 1/sigma(i);
            end
        end
        S_inv = diag(sigma_inv);

        % Calculate Jv pseudo-inverse
        Jv_inv = V*S_inv*U';

        % Calculate Step
        paramList_Step = Jv_inv*[P_error;O_error];

        %----- Update paramList
        paramList = wrapToPi(paramList + paramList_Step);

        %----- Check Tolerance
        error = max([P_error;O_error]);
        if error < error_tol
            tolNotReached = false;
        end
        
        %----- Check Time (10s for timeout error)
        t_max = 5; % s
        if (toc > t_max)
            fprintf('Timeout Error: Calculations exceeded 10 seconds, check your error\n');
            tolNotReached = false;
        end
    end
end